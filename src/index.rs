use crate::generation::Generation;

#[cfg(not(feature = "typed-index"))]
pub use untyped::Index;

#[cfg(not(feature = "typed-index"))]
pub(crate) fn create_index(slot: u32, generation: Generation) -> Index {
    Index { slot, generation }
}

#[cfg(feature = "typed-index")]
pub use typed::Index;

#[cfg(feature = "typed-index")]
pub(crate) fn create_index<T>(slot: u32, generation: Generation) -> Index<T> {
    Index {
        slot,
        generation,
        _marker: std::marker::PhantomData,
    }
}

#[cfg(not(feature = "typed-index"))]
pub mod untyped {
    use crate::generation::Generation;

    /// Untyped index type for [`Arena`](crate::Arena) that has a generation attached to it.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, PartialOrd, Ord)]
    pub struct Index {
        pub(crate) slot: u32,
        pub(crate) generation: Generation,
    }
}

#[cfg(feature = "typed-index")]
pub mod typed {
    use std::cmp::{Ord, Ordering, PartialOrd};
    use std::fmt;
    use std::hash::{Hash, Hasher};
    use std::marker::PhantomData;

    use crate::generation::Generation;

    /// Typed index type for [`Arena`](crate::Arena) that has a generation attached to it.
    pub struct Index<T> {
        pub(crate) slot: u32,
        pub(crate) generation: Generation,
        pub(crate) _marker: PhantomData<T>,
    }

    impl<T> fmt::Debug for Index<T> {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.debug_struct("Index<T>")
                .field("slot", &self.slot)
                .field("generation", &self.generation)
                .finish()
        }
    }

    impl<T> Clone for Index<T> {
        fn clone(&self) -> Self {
            Self {
                slot: self.slot,
                generation: self.generation,
                _marker: PhantomData,
            }
        }
    }

    impl<T> Copy for Index<T> {}

    impl<T> PartialEq for Index<T> {
        fn eq(&self, rhs: &Self) -> bool {
            self.slot.eq(&rhs.slot) && self.generation.eq(&rhs.generation)
        }
    }

    impl<T> Eq for Index<T> {}

    impl<T> Hash for Index<T> {
        fn hash<H: Hasher>(&self, state: &mut H) {
            self.slot.hash(state);
            self.generation.hash(state);
        }
    }

    impl<T> PartialOrd for Index<T> {
        fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
            Some(self.cmp(other))
        }
    }

    impl<T> Ord for Index<T> {
        fn cmp(&self, other: &Self) -> Ordering {
            self.slot
                .cmp(&other.slot)
                .then_with(|| self.generation.cmp(&other.generation))
        }
    }
}

macro_rules! index_impl {
    () => {
        /// Convert this `Index` to an equivalent `u64` representation. Mostly
        /// useful for passing to code outside of Rust.
        #[allow(clippy::integer_arithmetic)]
        pub fn to_bits(self) -> u64 {
            // This is safe because a `u32` bit-shifted by 32 will still fit in a `u64`.
            ((self.generation.to_u32() as u64) << 32) | (self.slot as u64)
        }

        /// Convert back from a value generated with `Index::to_bits`. Don't call
        /// this with arbitrary inputs; you'll almost certainly just get invalid
        /// and/or malformed indices.
        ///
        /// If fed an index which was not generated by thunderdome or even just run
        /// `Index::from_bits(0)`, this function may panic!
        #[allow(clippy::integer_arithmetic)]
        pub fn from_bits(bits: u64) -> Self {
            // By bit-shifting right by 32, we're undoing the left-shift in `to_bits`
            // thus this is okay by the same rationale.
            let generation = Generation::from_u32((bits >> 32) as u32);
            let slot = bits as u32;

            create_index(slot, generation)
        }

        /// Convert this `Index` into a slot, discarding its generation. Slots describe a
        /// location in an [`Arena`](crate::Arena) and are reused when entries are removed.
        pub fn slot(self) -> u32 {
            self.slot
        }
    };
}

#[cfg(not(feature = "typed-index"))]
impl Index {
    index_impl!();
}

#[cfg(feature = "typed-index")]
impl<T> Index<T> {
    index_impl!();
}
